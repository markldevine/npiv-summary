#!/usr/bin/env raku

#use lib '/home/mdevine/github.com/raku-Our-Utilities/lib';
#use lib '/home/mdevine/github.com/raku-Our-Grid/lib';
#use lib '/home/mdevine/github.com/raku-Our-Redis/lib';

use Async::Command::Multi;
use Our::Cache;
use Getopt::Long;
use Our::Grid;
use Our::Grid::Cell;
use JSON::Fast;
use Our::Utilities;

#use Data::Dump::Tree;
#use Grammar::Debugger;

#  fcs0             U78D8.ND0.FGD01TZ-P0-C1-C0-T0  PCIe3 2-Port 32Gb FC Adapter (df1000e314101506)
#
#        Part Number.................01FT700
#        Serial Number...............Y050HY1990A8
#        EC Level....................P14610
#        Customer Card ID Number.....578F
#        Manufacturer................001D
#        FRU Number..................01FT704
#        Device Specific.(ZM)........3
#        Network Address.............100000109BE073E1
#        Device Specific.(Z0)........0000000C
#        Device Specific.(Z1)........00000001
#        Device Specific.(Z2)........00000000
#        Device Specific.(Z3)........08090000
#        Device Specific.(Z4)........01003001
#        Device Specific.(Z5)........2E323537
#        Device Specific.(Z6)........2E323537
#        Device Specific.(Z7)........C0022C40
#        Device Specific.(Z8)........200000109BE073E1
#        Device Specific.(Z9)........12.4.257.30
#        Device Specific.(ZA)........12.4.257.30
#        Device Specific.(ZB)........30310000
#        Device Specific.(ZC)........00040000
#        Device Specific.(ZD)........000000FF
#        Hardware Location Code......U78D8.ND0.FGD01TZ-P0-C1-C0-T0
#
#
#  fcs0             U9080.HEX.78725A8-V255-C2155-T0  Virtual Fibre Channel Client Adapter
#
#        Network Address.............C050760C12130008
#        Device Specific.(Z0)........
#        Device Specific.(Z1)........
#        Device Specific.(Z2)........
#        Device Specific.(Z3)........
#        Device Specific.(Z4)........
#        Device Specific.(Z5)........
#        Device Specific.(Z6)........
#        Device Specific.(Z7)........
#        Device Specific.(Z8)........C050760C12130008
#        Device Specific.(Z9)........
#        Hardware Location Code......U9080.HEX.78725A8-V255-C2155-T0

my %vios-results;

my class FCS {
    has Str $.physical-location;
    has Str $.world-wide-node-name;
    has Str $.world-wide-port-name;
}

my class NPIV {
    has Str $.server-vadapter-location;
    has Int $.lpar-id;
    has Str $.lpar-name;
    has Str $.operating-system;
    has Str $.status;
    has Str $.vio-padapter-name;
    has Str $.vio-padapter-location;
    has Int $.ports-logged-in;
    has Str $.hex-flags;
    has Str $.client-fcs-device;
    has Str $.client-vadapter-location;
}

grammar FCS-grammar {
    token TOP {
        ^
        <fcs-record>+
    }
    token fcs-record {
        \s+ <fcs-device> \s+  
        .+?
        Network \s Address '.'+ <network-address>
        .+?
        Device \s Specific.\(Z8\) '.'+ <Z8>
        .+?
        Hardware \s Location \s Code '.'+ <hardware-location>
        .+?
    }
    token fcs-device        { fcs <fcs-number>                      }
    token fcs-number        { \d+                                   }
    token network-address   { <[0..9A..F]> ** 16                    }
    token Z8                { <[0..9A..F]> ** 16                    }
    token hardware-location { \w+ '.' \w+ '.' <[0..9A..F]>+ .+? $$  }
}

class FCS-actions {
    has $.vio-server    is required;

    method fcs-record ($/) {
        my Int $fcs-number = +$/<fcs-device><fcs-number>;
        %vios-results{$!vio-server}[$fcs-number]   = 
            FCS.new:
                :physical-location(~$/<hardware-location>),
                :world-wide-node-name(~$/<Z8>),
                :world-wide-port-name(~$/<network-address>),
            ;
    }
}

sub MAIN (
    Str                 :$hmc!,                                 #= HMC to query
    Bool                :$group-by-vios,                        #= group data around vio servers
    Bool                :$csv,                                  #= dump CSV to STDOUT
    Str                 :$grid-proxy-host   = '127.0.0.1',      #= hostname of grid proxy for remote services
    Bool                :$gui,                                  #= Graphical User Interface
    Bool                :$html,                                 #= dump HTML to STDOUT
    Bool                :$json,                                 #= dump JSON to STDOUT
#   Grid-Email-Formats  :$mail-body-format,                     #= email body format
                        :$mail-body-format,                     #= email body format
                        :$mail-from,                            #= email 'From:' addressee
                        :@mail-to,                              #= accumulate email 'To:' addressees
                        :@mail-cc,                              #= accumulate email 'Cc:' addressees
                        :@mail-bcc,                             #= accumulate email 'Bcc:' addressees
    Bool                :$text,                                 #= TEXT print
    Bool                :$tui,                                  #= Terminal User Interface
    Bool                :$xml,                                  #= dump XML to STDOUT
    Bool                :$light-mode,                           #= reverse header highlight for light-mode
) {
    my Bool $mailing;
    my $from                = $mail-from;
    my $format              = $mail-body-format;
    if $mail-from && @mail-to.elems {
        die '--mail-from=<email-address> required to send mail!' unless $mail-from;
        die '--mail-to=<email-address[,email-address]> required to send mail!' unless @mail-to.elems;
        $from               = $mail-from[0] if $mail-from ~~ Array;
        $format             = $mail-body-format[0] if $mail-body-format ~~ Array;
        $mailing = True;
    }
    my $reverse-highlight   = $light-mode ?? True !! False;
    my $preferences-cache-file-name = cache-file-name(:meta<preferences>);
    my $preferences-cache   = cache(:cache-file-name($preferences-cache-file-name));
    $preferences-cache      = from-json($preferences-cache) if $preferences-cache;
    without $light-mode {
        $reverse-highlight  = $preferences-cache<light-mode> if $preferences-cache<light-mode>:exists;
    }
    cache(:cache-file-name($preferences-cache-file-name), :data(to-json({light-mode => $reverse-highlight})));

    my %hmc;
    my %command;
    %command{$hmc}          = ['ssh', $hmc, 'lssyscfg', '-r', 'sys', '-F', 'name'];
    my $command-manager     = Async::Command::Multi.new(:%command, :20time-out, :8batch);
    my %results             = $command-manager.sow.reap;
    for %results.keys.sort(*.split(/\d+/, :kv).map({ (try .Numeric) // $_}).List) -> $hmc-server {
        for %results{$hmc-server}.stdout-results.trim.split("\n").list -> $managed-server {
            next unless $managed-server ~~ /9080 '-' HEX/;
            %hmc{$hmc-server}{$managed-server} = {};
        }
        die "No managed servers found on HMC '$hmc-server'!" unless %hmc{$hmc}.elems;
    }

    %command                = ();
    for %hmc{$hmc}.keys.sort(*.split(/\d+/, :kv).map({ (try .Numeric) // $_}).List) -> $managed-server {
        %command{$managed-server} = ['ssh', $hmc, 'lssyscfg', '-m', $managed-server, '-r', 'lpar', '-F', 'lpar_id,name'];
    }
    $command-manager        = Async::Command::Multi.new(:%command, :20time-out, :8batch);
    %results                = $command-manager.sow.reap;
    for %results.keys.sort(*.split(/\d+/, :kv).map({ (try .Numeric) // $_}).List) -> $managed-server {
        for %results{$managed-server}.stdout-results.trim.split("\n").list -> $record {
            my ($lpar-id, $name) = $record.split: ',';
            %hmc{$hmc}{$managed-server}<id2name>{$lpar-id}  = $name;
            %hmc{$hmc}{$managed-server}<name2id>{$name}     = $lpar-id;
        }
    }

    for %hmc{$hmc}.keys.sort(*.split(/\d+/, :kv).map({ (try .Numeric) // $_}).List) -> $managed-server {
        for %hmc{$hmc}{$managed-server}<name2id>.keys -> $name {
            %hmc{$hmc}{$managed-server}<vios>{$name} = {} if $name ~~ /vio/;
        }
    }

    %command                = ();
    for %hmc{$hmc}.keys.sort(*.split(/\d+/, :kv).map({ (try .Numeric) // $_}).List) -> $managed-server {
        for %hmc{$hmc}{$managed-server}<vios>.keys.sort(*.split(/\d+/, :kv).map({ (try .Numeric) // $_}).List) -> $vio {
            %command{$vio}      = ['ssh', 'padmin@' ~ $vio, 'ioscli', 'lsdev', '-dev', 'fcs*', '-vpd'];
        }
        $command-manager        = Async::Command::Multi.new(:%command, :20time-out, :8batch);
        %results                = $command-manager.sow.reap;
        for %results.keys.sort(*.split(/\d+/, :kv).map({ (try .Numeric) // $_}).List) -> $vio-server {
            FCS-grammar.parse(%results{$vio-server}.stdout-results, :actions(FCS-actions.new(:$vio-server)));
            die 'No fcs adapters found!' unless %vios-results{$vio-server}.elems;
            %hmc{$hmc}{$managed-server}<vios>{$vio-server}<fcs> = %vios-results{$vio-server};
        }
    }

    %command                = ();
    for %hmc{$hmc}.keys.sort(*.split(/\d+/, :kv).map({ (try .Numeric) // $_}).List) -> $managed-server {
        for %hmc{$hmc}{$managed-server}<vios>.keys -> $vio {
            %command{$vio}      = ['ssh', 'padmin@' ~ $vio, 'ioscli', 'lsmap', '-npiv', '-all', '-fmt', ':'];
        }
        $command-manager        = Async::Command::Multi.new(:%command, :20time-out, :8batch);
        %results                = $command-manager.sow.reap;
        for %results.keys.sort(*.split(/\d+/, :kv).map({ (try .Numeric) // $_}).List) -> $vio-server {
            for %results{$vio-server}.stdout-results.trim.split("\n").list -> $record {
                my @fields      = $record.split(':');
                %hmc{$hmc}{$managed-server}<vios>{$vio-server}<npiv>{@fields[0]} = NPIV.new:
                    :server-vadapter-location(@fields[1]),
                    :lpar-id(@fields[2].Int),
                    :lpar-name(@fields[3] ?? @fields[3] !! ''),
                    :operating-system(@fields[4]),
                    :status(@fields[5]),
                    :vio-padapter-name(@fields[6]),
                    :vio-padapter-location(@fields[7]),
                    :ports-logged-in(@fields[8].Int),
                    :hex-flags(@fields[9]),
                    :client-fcs-device(@fields[10]),
                    :client-vadapter-location(@fields[11]),
                ;
                %hmc{$hmc}{$managed-server}<vios>{$vio-server}<viopadaptername2vfchost>{@fields[6]}.push: @fields[0];
            }
        }
    }
    my Our::Grid $grid;
    if $group-by-vios {
        $grid  .= new: :title('NPIV Summary'), :$grid-proxy-host, :$reverse-highlight, :0group-by-column;
    }
    else {
        $grid  .= new: :title('NPIV Summary'), :$grid-proxy-host, :$reverse-highlight;
    }
#   $grid.add-heading('Managed Server',     :justification<left>),
    $grid.add-heading('VIO Server',         :justification<left>);
    $grid.add-heading('Physical Adapter',   :justification<left>);
    $grid.add-heading('Physical Location',  :justification<left>);
    $grid.add-heading('WW Node Name',       :justification<right>);
    $grid.add-heading('WW Port Name',       :justification<right>);
    $grid.add-heading('LPAR',               :justification<left>);
    $grid.add-heading('vfchost',            :justification<left>);
    $grid.add-heading('LPAR Adapter',       :justification<center>);
    $grid.add-heading('LPAR Location',      :justification<left>);
    $grid.add-heading('LPAR WW Node Name',  :justification<right>);
    for %hmc{$hmc}.keys.sort(*.split(/\d+/, :kv).map({ (try .Numeric) // $_}).List) -> $managed-server {
#       $grid.add-cell(:cell(Our::Grid::Cell.new(:text($managed-server), :bold,                                                                         :justification<left>)), :0col);
        for %hmc{$hmc}{$managed-server}<vios>.keys.sort(*.split(/\d+/, :kv).map({ (try .Numeric) // $_}).List) -> $vio {
            $grid.add-cell(:cell(Our::Grid::Cell.new(:text($vio),                                                                                       :justification<left>)), :0col);
            loop (my $fcs-number = 0; $fcs-number < %hmc{$hmc}{$managed-server}<vios>{$vio}<fcs>.elems; $fcs-number++) {
                next unless %hmc{$hmc}{$managed-server}<vios>{$vio}<fcs>[$fcs-number]:exists;
                $grid.add-cell(:cell(Our::Grid::Cell.new(:text('fcs' ~ $fcs-number),                                                                    :justification<left>)), :1col);
                $grid.add-cell(:cell(Our::Grid::Cell.new(:text(%hmc{$hmc}{$managed-server}<vios>{$vio}<fcs>[$fcs-number].physical-location),            :justification<left>)), :2col);
                $grid.add-cell(:cell(Our::Grid::Cell.new(:text(%hmc{$hmc}{$managed-server}<vios>{$vio}<fcs>[$fcs-number].world-wide-node-name),         :justification<left>)), :3col);
                $grid.add-cell(:cell(Our::Grid::Cell.new(:text(%hmc{$hmc}{$managed-server}<vios>{$vio}<fcs>[$fcs-number].world-wide-port-name),         :justification<left>)), :4col);
                for %hmc{$hmc}{$managed-server}<vios>{$vio}<viopadaptername2vfchost>{'fcs' ~ $fcs-number}.list -> $vfchost {
                    next unless $vfchost;
                    $grid.add-cell(:cell(Our::Grid::Cell.new(:text($vfchost),                                                                           :justification<left>)), :5col);
                    if %hmc{$hmc}{$managed-server}<vios>{$vio}<npiv>{$vfchost}.lpar-name {
                        $grid.add-cell(:cell(Our::Grid::Cell.new(:text(%hmc{$hmc}{$managed-server}<vios>{$vio}<npiv>{$vfchost}.lpar-name),              :justification<left>)), :6col);
                    }
                    else {
                        $grid.add-cell(:cell(Our::Grid::Cell.new(:text(''),                                                                             :justification<left>)), :6col);
                    }
                    $grid.add-cell(:cell(Our::Grid::Cell.new(:text(%hmc{$hmc}{$managed-server}<vios>{$vio}<npiv>{$vfchost}.client-fcs-device),          :justification<left>)), :7col);
                    $grid.add-cell(:cell(Our::Grid::Cell.new(:text(%hmc{$hmc}{$managed-server}<vios>{$vio}<npiv>{$vfchost}.client-vadapter-location),   :justification<left>)), :8col);
                    $grid.add-cell(:cell(Our::Grid::Cell.new(:text('TBD'),                                                                              :justification<left>)), :9col);
                    $grid.current-row++;
                }
            }
        }
    }
    {
        when $text          {   $grid.TEXT-print; }
        when $html          {   $grid.HTML-print; }
        when $csv           {   $grid.CSV-print;  }
        when $json          {   $grid.JSON-print; }
        when $mailing       {
                                $grid.send-proxy-mail-via-redis(
                                    :cro-host<127.0.0.1>,
                                    :22151cro-port,
                                    :mail-from($from),
                                    :@mail-to,
                                    :@mail-cc,
                                    :@mail-bcc,
                                    :$format,
                                );
        }
        when $xml           {   $grid.XML-print;  }
        when $tui           {   $grid.TUI;        }
        when $gui           {   $grid.GUI;        }
        default             {   $grid.ANSI-print; }
    }
}

=finish
