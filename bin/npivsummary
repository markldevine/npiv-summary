#!/usr/bin/env raku

#use lib '/home/mdevine/github.com/raku-Our-Utilities/lib';
#use lib '/home/mdevine/github.com/raku-Our-Grid/lib';
#use lib '/home/mdevine/github.com/raku-Our-Redis/lib';

use Async::Command::Multi;
use Our::Cache;
use Getopt::Long;
use Our::Grid;
use Our::Grid::Cell;
use JSON::Fast;
use Our::Utilities;

use Data::Dump::Tree;
#use Grammar::Debugger;

#  fcs0             U78D8.ND0.FGD01TZ-P0-C1-C0-T0  PCIe3 2-Port 32Gb FC Adapter (df1000e314101506)
#
#        Part Number.................01FT700
#        Serial Number...............Y050HY1990A8
#        EC Level....................P14610
#        Customer Card ID Number.....578F
#        Manufacturer................001D
#        FRU Number..................01FT704
#        Device Specific.(ZM)........3
#        Network Address.............100000109BE073E1
#        Device Specific.(Z0)........0000000C
#        Device Specific.(Z1)........00000001
#        Device Specific.(Z2)........00000000
#        Device Specific.(Z3)........08090000
#        Device Specific.(Z4)........01003001
#        Device Specific.(Z5)........2E323537
#        Device Specific.(Z6)........2E323537
#        Device Specific.(Z7)........C0022C40
#        Device Specific.(Z8)........200000109BE073E1
#        Device Specific.(Z9)........12.4.257.30
#        Device Specific.(ZA)........12.4.257.30
#        Device Specific.(ZB)........30310000
#        Device Specific.(ZC)........00040000
#        Device Specific.(ZD)........000000FF
#        Hardware Location Code......U78D8.ND0.FGD01TZ-P0-C1-C0-T0
#
#
#  fcs0             U9080.HEX.78725A8-V255-C2155-T0  Virtual Fibre Channel Client Adapter
#
#        Network Address.............C050760C12130008
#        Device Specific.(Z0)........
#        Device Specific.(Z1)........
#        Device Specific.(Z2)........
#        Device Specific.(Z3)........
#        Device Specific.(Z4)........
#        Device Specific.(Z5)........
#        Device Specific.(Z6)........
#        Device Specific.(Z7)........
#        Device Specific.(Z8)........C050760C12130008
#        Device Specific.(Z9)........
#        Hardware Location Code......U9080.HEX.78725A8-V255-C2155-T0

my %vios-results;

my class FCS {
    has Str $.physical-location;
    has Str $.world-wide-node-name;
    has Str $.world-wide-port-name;
}

my class NPIV {
    has Str $.server-vadapter-location;
    has Int $.lpar-id;
    has Str $.lpar-name;
    has Str $.operating-system;
    has Str $.status;
    has Str $.vio-padapter-name;
    has Str $.vio-padapter-location;
    has Int $.ports-logged-in;
    has Str $.hex-flags;
    has Str $.client-fcs-device;
    has Str $.client-vadapter-location;
}

grammar FCS-grammar {
    token TOP {
        ^
        <fcs-record>+
    }
    token fcs-record {
        \s+ <fcs-device> \s+  
        .+?
        Network \s Address '.'+ <network-address>
        .+?
        Device \s Specific.\(Z8\) '.'+ <Z8>
        .+?
        Hardware \s Location \s Code '.'+ <hardware-location>
        .+?
    }
    token fcs-device        { fcs <fcs-number>                      }
    token fcs-number        { \d+                                   }
    token network-address   { <[0..9A..F]> ** 16                    }
    token Z8                { <[0..9A..F]> ** 16                    }
    token hardware-location { \w+ '.' \w+ '.' <[0..9A..F]>+ .+? $$  }
}

class FCS-actions {
    has $.vio-server    is required;

    method fcs-record ($/) {
        my Int $fcs-number = +$/<fcs-device><fcs-number>;
        %vios-results{$!vio-server}[$fcs-number]   = 
            FCS.new:
                :physical-location(~$/<hardware-location>),
                :world-wide-node-name(~$/<Z8>),
                :world-wide-port-name(~$/<network-address>),
            ;
    }
}

sub MAIN (
    Str                 :$hmc!,                                 #= HMC to query
    Bool                :$group-by-system,                      #= group data around systems
    Bool                :$csv,                                  #= dump CSV to STDOUT
    Str                 :$grid-proxy-host   = '127.0.0.1',      #= hostname of grid proxy for remote services
    Bool                :$gui,                                  #= Graphical User Interface
    Bool                :$html,                                 #= dump HTML to STDOUT
    Bool                :$json,                                 #= dump JSON to STDOUT
#   Grid-Email-Formats  :$mail-body-format,                     #= email body format
                        :$mail-body-format,                     #= email body format
                        :$mail-from,                            #= email 'From:' addressee
                        :@mail-to,                              #= accumulate email 'To:' addressees
                        :@mail-cc,                              #= accumulate email 'Cc:' addressees
                        :@mail-bcc,                             #= accumulate email 'Bcc:' addressees
    Bool                :$text,                                 #= TEXT print
    Bool                :$tui,                                  #= Terminal User Interface
    Bool                :$xml,                                  #= dump XML to STDOUT
    Bool                :$light-mode,                           #= reverse header highlight for light-mode
    Int                 :@sort-columns,                         #= accumulate column numbers to sort by
    Bool                :$sort-descending,                      #= sort in descending order
) {
    my Bool $mailing;
    my $from                = $mail-from;
    my $format              = $mail-body-format;
    if $mail-from && @mail-to.elems {
        die '--mail-from=<email-address> required to send mail!' unless $mail-from;
        die '--mail-to=<email-address[,email-address]> required to send mail!' unless @mail-to.elems;
        $from               = $mail-from[0] if $mail-from ~~ Array;
        $format             = $mail-body-format[0] if $mail-body-format ~~ Array;
        $mailing = True;
    }
    my $reverse-highlight   = $light-mode ?? True !! False;
    my $preferences-cache-file-name = cache-file-name(:meta<preferences>);
    my $preferences-cache   = cache(:cache-file-name($preferences-cache-file-name));
    $preferences-cache      = from-json($preferences-cache) if $preferences-cache;
    without $light-mode {
        $reverse-highlight  = $preferences-cache<light-mode> if $preferences-cache<light-mode>:exists;
    }
    cache(:cache-file-name($preferences-cache-file-name), :data(to-json({light-mode => $reverse-highlight})));

    my %hmc;
    my %command;
    %command{$hmc}          = ['ssh', $hmc, 'lssyscfg', '-r', 'sys', '-F', 'name'];
    my $command-manager     = Async::Command::Multi.new(:%command, :20time-out, :8batch);
    my %results             = $command-manager.sow.reap;
    for %results.keys.sort -> $hmc-server {
        for %results{$hmc-server}.stdout-results.trim.split("\n").list -> $managed-server {
            next unless $managed-server ~~ /9080 '-' HEX/;
            %hmc{$hmc-server}{$managed-server} = {};
        }
        die "No managed servers found on HMC '$hmc-server'!" unless %hmc{$hmc}.elems;
    }

    %command                = ();
    for %hmc{$hmc}.keys.sort -> $managed-server {
        %command{$managed-server} = ['ssh', $hmc, 'lssyscfg', '-m', $managed-server, '-r', 'lpar', '-F', 'lpar_id,name'];
    }
    $command-manager        = Async::Command::Multi.new(:%command, :20time-out, :8batch);
    %results                = $command-manager.sow.reap;
    for %results.keys.sort -> $managed-server {
        for %results{$managed-server}.stdout-results.trim.split("\n").list -> $record {
            my ($lpar-id, $name) = $record.split: ',';
            %hmc{$hmc}{$managed-server}<id2name>{$lpar-id}  = $name;
            %hmc{$hmc}{$managed-server}<name2id>{$name}     = $lpar-id;
        }
    }

    for %hmc{$hmc}.keys.sort -> $managed-server {
        for %hmc{$hmc}{$managed-server}<name2id>.keys -> $name {
            %hmc{$hmc}{$managed-server}<vios>{$name} = {} if $name ~~ /vio/;
        }
    }

    %command                = ();
    for %hmc{$hmc}.keys.sort -> $managed-server {
        for %hmc{$hmc}{$managed-server}<vios>.keys -> $vio {
            %command{$vio}      = ['ssh', 'padmin@' ~ $vio, 'ioscli', 'lsdev', '-dev', 'fcs*', '-vpd'];
        }
        $command-manager        = Async::Command::Multi.new(:%command, :20time-out, :8batch);
        %results                = $command-manager.sow.reap;
        for %results.keys.sort -> $vio-server {
            FCS-grammar.parse(%results{$vio-server}.stdout-results, :actions(FCS-actions.new(:$vio-server)));
            die 'No fcs adapters found!' unless %vios-results{$vio-server}.elems;
            %hmc{$hmc}{$managed-server}<vios>{$vio-server}<fcs> = %vios-results{$vio-server};
        }
    }

    %command                = ();
    for %hmc{$hmc}.keys.sort -> $managed-server {
        for %hmc{$hmc}{$managed-server}<vios>.keys -> $vio {
            %command{$vio}      = ['ssh', 'padmin@' ~ $vio, 'ioscli', 'lsmap', '-npiv', '-all', '-fmt', ':'];
        }
        $command-manager        = Async::Command::Multi.new(:%command, :20time-out, :8batch);
        %results                = $command-manager.sow.reap;
        for %results.keys.sort -> $vio-server {
            for %results{$vio-server}.stdout-results.trim.split("\n").list -> $record {
                my @fields      = $record.split(':');
                %hmc{$hmc}{$managed-server}<vios>{$vio-server}<npiv>{@fields[0]} = NPIV.new:
                    :server-vadapter-location(@fields[1]),
                    :lpar-id(@fields[2].Int),
                    :lpar-name(@fields[3]),
                    :operating-system(@fields[4]),
                    :status(@fields[5]),
                    :vio-padapter-name(@fields[6]),
                    :vio-padapter-location(@fields[7]),
                    :ports-logged-in(@fields[8].Int),
                    :hex-flags(@fields[9]),
                    :client-fcs-device(@fields[10]),
                    :client-vadapter-location(@fields[11]),
                ;
            }
        }
    }
#ddt %hmc;

    my Our::Grid $grid;
    if $group-by-system {
        $grid  .= new: :title('df Report'), :$grid-proxy-host, :$reverse-highlight, :0group-by-column;
    }
    else {
        $grid  .= new: :title('df Report'), :$grid-proxy-host, :$reverse-highlight;
    }
    $grid.add-heading('Managed System', :justification<left>),
    $grid.add-heading('Filesystem',     :justification<left>);
    $grid.add-heading('Total',          :justification<right>);
    $grid.add-heading('Used',           :justification<right>);
    $grid.add-heading('Available',      :justification<right>);
    $grid.add-heading('% Used',         :justification<right>);
    $grid.add-heading('Mount Point',    :justification<left>);
    for %server-results.keys.sort -> $server {
        for %server-results{$server}.list -> $df-record {
            next if $df-record.cap-percent-num <= $percent-above;
            $grid.add-cell(:cell(Our::Grid::Cell.new(:text($server), :bold)));
            $grid.add-cell(:cell(Our::Grid::Cell.new(:text($df-record.filesystem),      :justification<left>)));
            $grid.add-cell(:cell(Our::Grid::Cell.new(:text($df-record.total-bytes),     :justification<right>,  :bytes-to-bytes-unit)));
            $grid.add-cell(:cell(Our::Grid::Cell.new(:text($df-record.used-bytes),      :justification<right>,  :bytes-to-bytes-unit)));
            $grid.add-cell(:cell(Our::Grid::Cell.new(:text($df-record.available-bytes), :justification<right>,  :bytes-to-bytes-unit)));
            if 70 <= $df-record.cap-percent-num < 80 {
                $grid.add-cell(:cell(Our::Grid::Cell.new(:text($df-record.capacity),    :justification<right>,  :foreground<yellow>)));
            }
            elsif 80 <= $df-record.cap-percent-num < 90 {
                $grid.add-cell(:cell(Our::Grid::Cell.new(:text($df-record.capacity),    :justification<right>,  :foreground<orange>)));
            }
            elsif 90 <= $df-record.cap-percent-num < 100 {
                $grid.add-cell(:cell(Our::Grid::Cell.new(:text($df-record.capacity),    :justification<right>,  :foreground<red>)));
            }
            elsif $df-record.cap-percent-num == 100 {
                $grid.add-cell(:cell(Our::Grid::Cell.new(:text($df-record.capacity),    :justification<right>,  :foreground<red>, :blink)));
            }
            else {
                $grid.add-cell(:cell(Our::Grid::Cell.new(:text($df-record.capacity),    :justification<right>)));
            }
            $grid.add-cell(:cell(Our::Grid::Cell.new(:text($df-record.mount-point),     :justification<left>)));
            $grid.current-row++;
        }
    }
    if @sort-columns.elems {
#       my Int @sort-columns = $sort-columns.split(',').map({ $_.Int });
        $grid.sort-by-columns(:@sort-columns, :descending($sort-descending));
    }
    {
        when $text          {   $grid.TEXT-print; }
        when $html          {   $grid.HTML-print; }
        when $csv           {   $grid.CSV-print;  }
        when $json          {   $grid.JSON-print; }
        when $mailing       {
                                $grid.send-proxy-mail-via-redis(
                                    :cro-host<127.0.0.1>,
                                    :22151cro-port,
                                    :mail-from($from),
                                    :@mail-to,
                                    :@mail-cc,
                                    :@mail-bcc,
                                    :$format,
                                );
        }
        when $xml           {   $grid.XML-print;  }
        when $tui           {   $grid.TUI;        }
        when $gui           {   $grid.GUI;        }
        default             {   $grid.ANSI-print; }
    }
}

=finish
